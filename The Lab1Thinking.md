The Thinking
============
小明的烦恼
-------------
##思考1
  深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上
  。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件printf.c删除掉了。苦恼的小明向你求助，你觉得怎样能帮他把代码文件恢复呢？<br>
###解决方法
    首先，他是更改了工作区的文件，并且没有上传，所以可以直接重新利用
    git checkout print.c
    来恢复print.c文件，因为print.c文件是在OSLAB库里面有存储，所以可以直接得到
##思考2
正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘
上敲下了
git rm printf.c
，这下事情更复杂了，现在你又该如何处理才能弥补
小红的过错呢？
###解决方法
  这次是把暂存区的print.c也给删掉了，这是可以先用
  git reset HEAD print.c
  方法把print.c文件找回到暂存区中，再利用git checkout指令找回
##思考3
处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小
明的仓库里有一个叫
Tucao.txt
，你好奇地打开一看，发现是吐槽操作系统
实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置
才能使
Tucao.txt
在不从工作区删除的情况下不会被
git commit
指令提交到
版本库？
###解决方法
  利用git clean Tucao.txt清除了他就可以了

有关克隆问题的思考
-------------------------
##思考1
克隆时所有分支均被克隆，但只有 HEAD 指向的分支被检出。
###判断
  正确，克隆时是克隆所以远程仓库中的内容。根据官方文档`Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using git branch -r), and creates and checks out an initial branch that is forked from the cloned repository’s currently active branch.`这句话中第一句就可以得知克隆时克隆所以仓库中的内容
##思考2
克隆出的工作区中执行 git log、git status、git checkout、git commit 等操作 不会去访问远程版本库。
###判断
  正确，在实验中我们不难发现，在我们提交作业时，`git add`和`git commit`操作执行后并没有直接的得到实验结果，而是提示我们有文件进行了更改，
  之后执行`git push`操作后得出结果，可以得知此时远程版本库被更改。
##思考3
克隆时只有远程版本库 HEAD 指向的分支被克隆。
###判断
  错误，正确的应该是所有分支被克隆，但只有HEAD分支被检出。理由在第一题中有所叙述。
##思考4
克隆后工作区的默认分支处于 master 分支。
###判断
  正确。在我们进行试验时，工作区默认确实在master分支中，同时官方文档中也给出了类似的描述` creates and checks out an initial branch that is forked from the cloned repository’s currently active branch.`这句话中的`initial branch`默认应该为master分支

难点流程
--------------------
##难点
个人认为难点在print.c的函数补全上。
###具体解决流程
  首先是根据注释来具体体会出需要补全的部分是什么。通过第一个for循环可以看出，需要我们补全的部分是关于%前的部分的字符打印和%后到具体标
  识符之前的内容格式整理。首先是for循环中寻找%字符，并且打印%字符之前的所有字符。这里的方法有两种，第一种是利用`OUTPUT`函数对正串字符
  进行打印，第二种则是一个字符一个字符打印。而代码中并没有给出`OUTPUT`函数所利用的`output`函数的具体实现，所以我选择参考了后面的运用方
  法来使用OUTPUT函数，就是第一种方法。在实现字符串的直接打印时，需要得到字符串长度和字符串的头，所以不能只利用fmt指针来进行编辑（这样
  会弄丢字符串头的位置），利用fmthead指针保存对应的字符串头，这样对普通文本的打印就实现了。
  之后是操作特殊符号的判断，这步我是参考着printf函数的函数说明进行的修改，过程也比较容易，只要根据之后的help部分中的函数体来确定具体的
  变量的作用(longFlag是长整形的判断符，negFlag是负数的判断符，ladjust是左对齐，Prad是具体的左对齐补位等等）得知了具体变量的作用，根据这
  些变量对应的指示符修改即可。
  
##难度评价
  第一次作业难度还是很低的，主要是上手难度比较大，同时跟课上的内容关联的不明显，很多内容基本上不是课上讲的，而是完全是自己根据指导书来自
  学。一上手的茫然还是很可怕的。之后的内容只要比较熟悉了之后还是很好理解的。入门级别的实验吧，难度在5-6分左右，主要是操作起来太不熟悉，
  指导书也不是很容易理解，需要翻来覆去的做很多遍才能正式开始实验。但是总体难度不高，我利用了两次习题课(约6个小时)以及课下的零散时间来不断
  的实验(大部分时间都是在git的实验上)具体有5-6个小时，总共有10-12个小时，时间跨度为三周
##心得体会
  OS的实验与计算机组成原理的实验差别还是很大的，OS的实验更加注重的是大家的自学能力和学习能力的培养，同时课程也是以拓展视野为主，让大家能更
  好的了解操作系统，而具体实现一个操作系统的难度还是有的。OS的实验时间上比较宽松，更加注重大家兴趣的培养吧，个人感觉操作系统的实验很有意义
  ，我本人也在找一些操作系统的书来看，总的来说这是一个很广阔的领域，需要不断的探索。
